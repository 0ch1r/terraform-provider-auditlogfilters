#!/usr/bin/env python3
"""
Convert audit log filter JSON into Terraform `jsonencode` shape used by
terraform-provider-auditlogfilters.
"""

import argparse
import json
import re
import sys
from pathlib import Path
from typing import Any


IDENTIFIER_RE = re.compile(r"^[A-Za-z_][A-Za-z0-9_]*$")


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description=(
            "Normalize audit log filter JSON and output Terraform-compatible "
            "jsonencode object syntax."
        )
    )
    parser.add_argument(
        "input",
        nargs="?",
        help="Path to JSON file. If omitted, reads JSON from stdin.",
    )
    parser.add_argument(
        "--json",
        action="store_true",
        help="Output normalized JSON instead of Terraform HCL snippet.",
    )
    parser.add_argument(
        "--resource-name",
        default="example_filter",
        help="Terraform resource name to use with --full-resource (default: example_filter).",
    )
    parser.add_argument(
        "--filter-name",
        default="example_filter",
        help="Filter name attribute to use with --full-resource (default: example_filter).",
    )
    parser.add_argument(
        "--full-resource",
        action="store_true",
        help="Output a full auditlogfilters_filter resource block.",
    )
    return parser.parse_args()


def read_input(input_path: str | None) -> str:
    if input_path:
        return Path(input_path).read_text(encoding="utf-8")
    return sys.stdin.read()


def ensure_provider_shape(raw: Any) -> dict[str, Any]:
    if isinstance(raw, str):
        raw = json.loads(raw)

    if not isinstance(raw, dict):
        raise ValueError("Top-level JSON value must be an object.")

    if "definition" in raw:
        definition = raw["definition"]
        if isinstance(definition, str):
            raw = json.loads(definition)
        elif isinstance(definition, dict):
            raw = definition
        else:
            raise ValueError("If present, `definition` must be a JSON object or JSON string.")

    if "filter" not in raw:
        raw = {"filter": raw}

    if not isinstance(raw.get("filter"), dict):
        raise ValueError("`filter` must be a JSON object.")

    return raw


def hcl_key(key: str) -> str:
    if IDENTIFIER_RE.match(key):
        return key
    return json.dumps(key)


def to_hcl(value: Any, indent: int = 0) -> str:
    space = " " * indent
    next_indent = indent + 2
    next_space = " " * next_indent

    if isinstance(value, dict):
        if not value:
            return "{}"
        lines = ["{"]
        for key, item in value.items():
            rendered = to_hcl(item, next_indent)
            lines.append(f"{next_space}{hcl_key(str(key))} = {rendered}")
        lines.append(f"{space}}}")
        return "\n".join(lines)

    if isinstance(value, list):
        if not value:
            return "[]"
        lines = ["["]
        for item in value:
            rendered = to_hcl(item, next_indent)
            lines.append(f"{next_space}{rendered}")
        lines.append(f"{space}]")
        return "\n".join(lines)

    return json.dumps(value, ensure_ascii=False)


def render_definition_block(normalized: dict[str, Any], indent: int = 2) -> str:
    rendered = to_hcl(normalized, indent)
    prefix = " " * indent
    return f"definition = jsonencode({rendered}\n{prefix})"


def render_resource(normalized: dict[str, Any], resource_name: str, filter_name: str) -> str:
    definition = render_definition_block(normalized, indent=2)
    return (
        f'resource "auditlogfilters_filter" "{resource_name}" {{\n'
        f'  name = "{filter_name}"\n'
        f"  {definition}\n"
        "}\n"
    )


def main() -> int:
    args = parse_args()

    try:
        raw_text = read_input(args.input)
        if not raw_text.strip():
            raise ValueError("No JSON input found. Provide a file path or pipe JSON to stdin.")

        parsed = json.loads(raw_text)
        normalized = ensure_provider_shape(parsed)
    except (json.JSONDecodeError, ValueError) as err:
        print(f"json-helper error: {err}", file=sys.stderr)
        return 1

    if args.json:
        print(json.dumps(normalized, indent=2, ensure_ascii=False))
        return 0

    if args.full_resource:
        print(render_resource(normalized, args.resource_name, args.filter_name), end="")
        return 0

    print(render_definition_block(normalized))
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
